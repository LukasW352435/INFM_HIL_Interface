/**
 * HIL - REST Dummy DuT
 * This is a sample component description for a REST server as dummy DuT
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 5.2.1.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


#include <corvusoft/restbed/byte.hpp>
#include <corvusoft/restbed/string.hpp>
#include <corvusoft/restbed/settings.hpp>
#include <corvusoft/restbed/request.hpp>
#include <iostream>

#include "DefaultApi.h"

namespace thi::dummy_dut::api {

    using namespace thi::dummy_dut::model;

    DefaultApi::DefaultApi() {
    }

    DefaultApi::~DefaultApi() {}

    void DefaultApi::startService(int const &port) {
        // A typical pattern is to derive a class from DefaultApi and allocate the shared pointers for restbed::Resource objects
        // and manipulate them (e.g. binding GET/POST handler functions) before this startService() gets called.
        // In such a case we want to use our m_spXXX variables.
        // However in case these shared pointers are nullptr, then allocate the restbed::Resources now:
        if (!m_spDefaultApiDashboardResource)
            m_spDefaultApiDashboardResource = std::make_shared<DefaultApiDashboardResource>();
        this->publish(m_spDefaultApiDashboardResource);
        if (!m_spDefaultApiDashboardMessagesResource)
            m_spDefaultApiDashboardMessagesResource = std::make_shared<DefaultApiDashboardMessagesResource>();
        this->publish(m_spDefaultApiDashboardMessagesResource);
        if (!m_spDefaultApiSendResource)
            m_spDefaultApiSendResource = std::make_shared<DefaultApiSendResource>();
        this->publish(m_spDefaultApiSendResource);
        if (!m_spDefaultApiReadClientUrlResource)
            m_spDefaultApiReadClientUrlResource = std::make_shared<DefaultApiReadResource>();
        this->publish(m_spDefaultApiReadClientUrlResource);

        std::shared_ptr<restbed::Settings> settings = std::make_shared<restbed::Settings>();
        settings->set_port(port);
        settings->set_root("");

        this->start(settings);
    }

    void DefaultApi::stopService() {
        this->stop();
    }

    DefaultApiDashboardResource::DefaultApiDashboardResource() {
        this->set_path("/dashboard/");
        this->set_method_handler("GET",
                                 std::bind(&DefaultApiDashboardResource::GET_method_handler, this,
                                           std::placeholders::_1));
        this->set_method_handler("POST",
                                 std::bind(&DefaultApiDashboardResource::POST_method_handler, this,
                                           std::placeholders::_1));
    }

    DefaultApiDashboardResource::~DefaultApiDashboardResource() {
    }

    void DefaultApiDashboardResource::set_handler_GET(
            std::function<std::pair<int, std::string>(

            )> handler) {
        handler_GET_ = std::move(handler);
    }

    void DefaultApiDashboardResource::set_handler_POST(
            std::function<std::pair<int, std::string>(
                    std::shared_ptr<Message> const &
            )> handler) {
        handler_POST_ = std::move(handler);
    }

    void DefaultApiDashboardResource::GET_method_handler(const std::shared_ptr<restbed::Session> session) {

        const auto request = session->get_request();


        int status_code = 501;
        std::string result = "Method not implemented";

        if (handler_GET_) {
            std::tie(status_code, result) = handler_GET_(

            );
        }

        if (status_code == 200) {
            session->close(200, result.empty() ? "HTML web page" : std::move(result), {{"Connection", "close"}});
            return;
        }
        session->close(status_code, result, {{"Connection", "close"}});

    }

    void DefaultApiDashboardResource::POST_method_handler(const std::shared_ptr<restbed::Session> session) {

        const auto request = session->get_request();
        // Body params are present, therefore we have to fetch them
        int content_length = request->get_header("Content-Length", 0);
        session->fetch(content_length,
                       [this](const std::shared_ptr<restbed::Session> session, const restbed::Bytes &body) {

                           const auto request = session->get_request();
                           std::string file = restbed::String::format("%.*s\n", (int) body.size(), body.data());

                           message = std::make_shared<Message>();
                           message->fromJsonString(file);


                           int status_code = 501;
                           std::string result = "Method not implemented";

                           if (handler_POST_) {
                               std::tie(status_code, result) = handler_POST_(
                                       message
                               );
                           }

                           if (status_code == 201) {
                               session->close(201, result.empty() ? "Message accepted" : std::move(result),
                                              {{"Connection", "close"}});
                               return;
                           }
                           if (status_code == 400) {
                               session->close(400, result.empty() ? "Invalid message supplied" : std::move(result),
                                              {{"Connection", "close"}});
                               return;
                           }
                           session->close(status_code, result, {{"Connection", "close"}});

                       });
    }


    DefaultApiDashboardMessagesResource::DefaultApiDashboardMessagesResource() {
        this->set_path("/dashboard/messages/");
        this->set_method_handler("GET",
                                 std::bind(&DefaultApiDashboardMessagesResource::GET_method_handler, this,
                                           std::placeholders::_1));
    }

    DefaultApiDashboardMessagesResource::~DefaultApiDashboardMessagesResource() {
    }


    void DefaultApiDashboardMessagesResource::GET_method_handler(const std::shared_ptr<restbed::Session> session) {
        const auto headers = std::multimap<std::string, std::string>{
                {"Connection",    "keep-alive"},
                {"Cache-Control", "no-cache"},
                {"Content-Type",  "text/event-stream"}
        };
        session->yield(200, headers, [this](const std::shared_ptr<restbed::Session> &session) {
            sessions.push_back(session);
        });
    }


    DefaultApiSendResource::DefaultApiSendResource() {
        this->set_path("/send/");
        this->set_method_handler("PUT",
                                 std::bind(&DefaultApiSendResource::PUT_method_handler, this,
                                           std::placeholders::_1));
    }

    DefaultApiSendResource::~DefaultApiSendResource() {
    }

    void DefaultApiSendResource::set_handler_PUT(
            std::function<std::pair<int, std::string>(
                    std::shared_ptr<Message> const &
            )> handler) {
        handler_PUT_ = std::move(handler);
    }


    void DefaultApiSendResource::PUT_method_handler(const std::shared_ptr<restbed::Session> session) {

        const auto request = session->get_request();
        // Body params are present, therefore we have to fetch them
        int content_length = request->get_header("Content-Length", 0);
        session->fetch(content_length,
                       [this](const std::shared_ptr<restbed::Session> session, const restbed::Bytes &body) {

                           const auto request = session->get_request();
                           std::string file = restbed::String::format("%.*s\n", (int) body.size(), body.data());
                           /**
                            * Get body params or form params here from the file string
                            */
                           message = std::make_shared<Message>();
                           message->fromJsonString(file);


                           int status_code = 501;
                           std::string result = "Method not implemented";

                           if (handler_PUT_) {
                               std::tie(status_code, result) = handler_PUT_(
                                       message
                               );
                           }

                           if (status_code == 200) {
                               session->close(200, result.empty() ? "Message accepted" : std::move(result),
                                              {{"Connection", "close"}});
                               return;
                           }
                           if (status_code == 400) {
                               session->close(400, result.empty() ? "Invalid message supplied" : std::move(result),
                                              {{"Connection", "close"}});
                               return;
                           }
                           session->close(status_code, result, {{"Connection", "close"}});

                       });
    }


    DefaultApiReadResource::DefaultApiReadResource() {
        this->set_path("/read/");
        this->set_method_handler("POST",
                                 std::bind(&DefaultApiReadResource::POST_method_handler, this,
                                           std::placeholders::_1));
        this->set_method_handler("DELETE",
                                 std::bind(&DefaultApiReadResource::DELETE_method_handler, this,
                                           std::placeholders::_1));
    }

    DefaultApiReadResource::~DefaultApiReadResource() {
    }

    void DefaultApiReadResource::set_handler_POST(
            std::function<std::pair<int, std::string>(
                    std::string const &
            )> handler) {
        handler_POST_ = std::move(handler);
    }

    void DefaultApiReadResource::set_handler_DELETE(
            std::function<std::pair<int, std::string>(
                    std::string const &
            )> handler) {
        handler_DELETE_ = std::move(handler);
    }

    void DefaultApiReadResource::POST_method_handler(const std::shared_ptr<restbed::Session> session) {

        const auto request = session->get_request();

        // Getting the query params
        const std::string clientUrl = request->get_query_parameter("clientUrl", "");

        int status_code = 501;
        std::string result = "Method not implemented";

        if (handler_POST_) {
            std::tie(status_code, result) = handler_POST_(
                    clientUrl
            );
        }

        if (status_code == 200) {
            session->close(200, result.empty() ? "Subscription registered" : std::move(result),
                           {{"Connection", "close"}});
            return;
        }
        if (status_code == 208) {
            session->close(208, result.empty() ? "Subscription already registered" : std::move(result),
                           {{"Connection", "close"}});
            return;
        }
        if (status_code == 400) {
            session->close(400, result.empty() ? "Not a valid client URL" : std::move(result),
                           {{"Connection", "close"}});
            return;
        }
        session->close(status_code, result, {{"Connection", "close"}});

    }

    void DefaultApiReadResource::DELETE_method_handler(const std::shared_ptr<restbed::Session> session) {

        const auto request = session->get_request();

        // Getting the query params
        const std::string clientUrl = request->get_query_parameter("clientUrl", "");


        int status_code = 501;
        std::string result = "Method not implemented";

        if (handler_DELETE_) {
            std::tie(status_code, result) = handler_DELETE_(
                    clientUrl
            );
        }

        if (status_code == 200) {
            session->close(200, result.empty() ? "Unsubscription successful" : std::move(result),
                           {{"Connection", "close"}});
            return;
        }
        if (status_code == 400) {
            session->close(400, result.empty() ? "Not a valid client URL" : std::move(result),
                           {{"Connection", "close"}});
            return;
        }
        if (status_code == 404) {
            session->close(404, result.empty() ? "Client ID not found" : std::move(result), {{"Connection", "close"}});
            return;
        }
        session->close(status_code, result, {{"Connection", "close"}});

    }


}

